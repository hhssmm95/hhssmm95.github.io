---
layout: post
title: 언리얼 C++ Study - 언리얼 C++ 코딩 규칙
date: 2025-02-21 18:26 +0900
categories: [UnrealEngine]
tags: [UnrealEngine]
---

# 언리얼 C++ 코딩규칙

 



## 강의 목표

- 프로그래밍을 시작하기 전에 알아두어야 할 언리얼 C++ 코딩 표준을 이해
- 언리얼 C++ 표준 코딩 표준에서 주의할 점의 확인

 



## 코딩 표준

 



### 코딩 표준의 의의

- 가독성 향상

- 유지보수 비용 절감

- 개발자 커뮤니티에 공유 시 답을 받기가 더 쉬움

- 크로스 컴파일러 호환성에 필요

   
  
  

### 클래스 체계

- 클래스 작성 시, 접근지정자 public과 private 중, public 선언을 먼저 상단에 작성 하기





### 명명 규칙

- 기본적으로 언리얼 C++에서는 독자적인 **파스칼 케이싱** 채용 (합성어의 첫 글자를 대문자로 표기)
- 템플릿 클래스에는 접두사 **T** 붙이기
- UObject 상속 클래스는 접두사 **U** 붙이기
- AActor 상속 클래스는 접두사 **A** 붙이기
- SWidget 상속 클래스는 접두사 **S** 붙이기
- 추상적 인터페이스 클래스는 접두사 **I** 붙이기
- 열거형은 접두사 **E** 붙이기
- 부울 변수는 접두사 **b** 붙이기
- 그 외 일반적인 C++ 클래스 (언리얼 비상속 클래스) 혹은 구조체는 접두사 **F** 붙이기
- 타입 및 변수 이름은 **명사**
- 메서드 이름은 메서드의 기능을 설명하거나, 기능이 없는 메서드의 반환 값을 설명하는 **동사**
- 매크로 이름은 **모두** **대문자**로 구성되고, 단어가 **언더스코어로 분리**되며, 접두사 **UE_**를 사용할 것

 



### 기타 명명 규칙 표준

- 모든 명명은 이름이 명확하고 확실하며, 내용을 파악할 수 있도록 짓기
- 변수의 의미에 대한 코멘트를 작성할 수 있도록, 모든 변수는 한 줄에 하나씩 선언하기
- 부울을 반환하는 모든 함수는 질의형으로 명명하기
  - `IsVisible()`
  - `ShouldClearBuffer()`
- 다음 조건이 모두 충족되는 경우 패러미터에 `Out` 접두사를 붙이기
  - 함수 패러미터가 참조로 전달 되는 경우
  - 함수에서 그 값을 덮어 쓸 것으로 예상 되는 경우
- 자료형을 사용할 때는 언리얼에서 제공하는 타입을 사용할 것
  - uint8, int32, TCHAR 등





### 표준 라이브러리

- C++ 표준 라이브러리는 부분적으로 적용할 수 있으나 언리얼 라이브러리와 혼용 하는것은 지양해야함





### const 지시어

- const 지시어는 가능한 경우 모두 적용하는 것이 바람직함 (함수 패러미터, 함수 권한, 루프 등등)





### c++ 최신 버전

- 언리얼5 최신 버전에서는 기본적으로 C++ 20을 채용하고 있으나 강의에서는 구버전이므로 C++17을 사용함





### c++ 규칙 관련

- override, final 키워드는 적극적으로 사용할 것
- nullptr도 그대로 사용할 수 있음
- auto 키워드는 람다를 바인딩 하는 경우, 이터레이터 등을 사용할 때 가독성에 악영향을 끼치는 경우 등의 특수한 경우에만 사용할 것
- 범위기반 for는 적극 사용 권장, 가독성 이득
- 람다는 안정적으로 어떻게 사용하는지 명확하게 인지한 상황에서 명시적으로 사용하는것을 권장
- 열거형은 enum class 사용 권장
- 이동 연산을 위해서는 표준 라이브러리의 std::move말고 언리얼 버전인 MoveTemp를 사용할 것
- 클래스의 멤버 디폴트 값을 지정하는것 보다는 클래스 생성자에서 값을 초기화 하는것을 권장함
- 서드파티 코드는 코멘트로 명시할 것
- 중괄호의 경우는 한 줄 짜리 코드에도 중괄호를 포함하는것을 권장
- 들여쓰기는 탭으로
- switch문 작성 시 이 case에서는 다음 case로 이어져 넘어간다고 falls through 코멘트를 달아 주는 것이 좋음, 혹은 모든 경우마다 break를 넣는 것 권장하며 default case는 항상 생성할 것

 



### 물리적 종속성

- 파일 이름에는 타입/변수와 달리 접두사를 붙이지 않아야 하며, 모든 헤더에서는 #pragma once로 복수의 include를 방지할 것
- \#include는 세밀하게 호출하며, 가급적 최소화 할것





### 캡슐화

- 클래스 멤버는 가급적 프라이빗으로 선언하며 목적에 따라 public protected로 선언하고, 접근지정자는 반드시 작성할 것, 마지막 파생 클래스인 경우 final 붙일것

 



### 코딩 스타일 관련

- 객체 종속성에 항상 신경 쓸 것
- 스트링 리터럴에는 항상 `TEXT()` 매크로를 사용할 것, 그렇지 않으면 원치 않는 <FString>이 생성되어 변환 프로세스를 유발할 수 있음
- 코드 가독성에 항상 신경 쓸 것 (특히 논리 연산)
- 포인터와 레퍼런스 작성 규칙은 반드시 `FShaderType* Ptr` 식으로 타입 오른쪽에 바로 붙여서 사용할 것, 그래야 빠르게 Find In Files를 수행할 수 있음
- 섀도잉 (컴파일적으로는 허용된 변수명 중복)을 주의할 것
- 함수 호출 시 즉석 리터럴 값을 넘기는 것을 지양하고, 코드가 길어지더라도 보는 이가 명확하게 이해할 수 있도록 변수로 선언하여 넘겨야 함
- 헤더에 특수한 스택 변수를 정의하면 안됨, extern 키워드 등을 통해 존재만 알려주고 정의는 cpp에 있도록 해야함 (원치 않는 인스턴스 방지)
